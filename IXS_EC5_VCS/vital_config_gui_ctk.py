#! /usr/bin/env python
#  -*- coding: utf-8 -*-
#
# GUI module generated by PAGE version 6.2
#  in conjunction with Tcl version 8.6
#    Dec 11, 2022 05:45:38 PM EST  platform: Darwin
# imports go here
import sys, subprocess
# for any tool that might potentially be used by someone other than myself, i've started to wrap the imports in try/except blocks
# for this one, i just want to double check that pip is properly installed first because i am (unfortunately) using multiple third-party libraries
try:
    import pip
except ImportError:
    print(f'An error has occurred with the program and it needs to terminate. Inform your system administrator that "pip is not installed properly".')
    quit()
# setting up a function to install pip packages in case they're not installed
def install(package):
    subprocess.check_call([sys.executable, "-m", "pip", "install", package])
# setting a variable to check if any imports failed, and if not then the program will continue
fail = False
# this module doesn't end up getting used but PAGE likes to import it and i like to leave it alone
try:
    import tkinter.ttk as ttk
except ImportError:
    fail = True
    print(f'WARNING: MODULE tkinter MISSING, ATTEMPTING TO INSTALL')
    install('tkinter')
# found this module on YouTube actually, on a video about making more modern GUIs with Python than using just plain old tkinter
# i love tkinter to death, but man does it suffer from looking boring as can be. at some point i'll invest the time into learning pyqt5
try:
    import customtkinter as tk
except ImportError:
    fail = True
    print(f'WARNING: MODULE customtkinter MISSING, ATTEMPTING TO INSTALL')
    install('customtkinter')
# pyautogui is also a fantastic library; i need to learn more about it
try:
    import pyautogui
except ImportError:
    fail = True
    print(f'WARNING: MODULE pyautogui MISSING, ATTEMPTING TO INSTALL')
    install('customtkinter')
# if any imports failed, print a console message (which doesn't end up showing up anywhere for right now. i need to fix that.) and then quit
if fail == True:
    print(f'WARNING: ONE OR MORE MODULES WERE MISSING AND HAVE BEEN INSTALLED. THE PROGRAM WILL NEED TO BE RE-RUN AS A RESULT. IF YOU RECEIVE THIS ERROR MORE THAN ONCE, CONTACT YOUR SYSTEM ADMINISTRATOR.')
    quit()
# initializing variables
def init(top, gui, *args, **kwargs):
    global w, top_level, root
    w = gui
    top_level = top
    root = top
#
def destroy_window():
    # Function which closes the window.
    global top_level
    top_level.destroy()
    top_level = None
# initializing checkbutton variables
def set_Tk_var():
    global check1
    check1 = tk.IntVar()
    global check2
    check2 = tk.IntVar()
    global check3
    check3 = tk.IntVar()
    global check4
    check4 = tk.IntVar()
    global check5
    check5 = tk.IntVar()
    global check6
    check6 = tk.IntVar()
    global check7
    check7 = tk.IntVar()
    global check8
    check8 = tk.IntVar()
    global check9
    check9 = tk.IntVar()
    global check10
    check10 = tk.IntVar()
    global check11
    check11 = tk.IntVar()
    global check12
    check12 = tk.IntVar()
    global check13
    check13 = tk.IntVar()
    global check14
    check14 = tk.IntVar()
    global check15
    check15 = tk.IntVar()
    global check16
    check16 = tk.IntVar()
    global check17
    check17 = tk.IntVar()
    global check18
    check18 = tk.IntVar()
    global check19
    check19 = tk.IntVar()
    global check20
    check20 = tk.IntVar()
    global check21
    check21 = tk.IntVar()
    global check22
    check22 = tk.IntVar()
    global check23
    check23 = tk.IntVar()
    global check24
    check24 = tk.IntVar()
    global check25
    check25 = tk.IntVar()
    global check26
    check26 = tk.IntVar()
    global check27
    check27 = tk.IntVar()
    global check28
    check28 = tk.IntVar()
    global check29
    check29 = tk.IntVar()
    global check30
    check30 = tk.IntVar()
    global check31
    check31 = tk.IntVar()
    global check32
    check32 = tk.IntVar()
# this is the start point
def vp_start_gui():
    '''Starting point when module is the main routine.'''
    global val, w, root
    root = tk.CTk()
    set_Tk_var()
    top = window_main(root)
    init(root, top)
    root.mainloop()
w = None
#
def create_window_main(rt, *args, **kwargs):
    '''Starting point when module is imported by another module.
       Correct form of call: 'create_window_main(root, *args, **kwargs)' .'''
    global w, w_win, root
    root = rt
    w = tk.Toplevel (root)
    set_Tk_var()
    top = window_main (w)
    init(w, top, *args, **kwargs)
    return (w, top)
# destroys the window
def destroy_window_main():
    global w
    w.destroy()
    w = None
# the main window class
class window_main:
    def __init__(self, top=None):
        '''This class configures and populates the toplevel window.
           top is the toplevel containing window.'''
        _bgcolor = '#d9d9d9'  # X11 color: 'gray85'
        _fgcolor = '#000000'  # X11 color: 'black'
        _compcolor = '#d9d9d9' # X11 color: 'gray85'
        _ana1color = '#d9d9d9' # X11 color: 'gray85'
        _ana2color = '#ececec' # Closest X11 color: 'gray92'
        # i've set the geometry in such a way that it looks nice, the 2 banks of 16-bit setting switches are separate, and it cannot be resized.
        # this ensures the window always looks the way i wanted it to originally, and also simplifies the screenshot logic
        top.geometry("450x600+525+199")
        top.minsize(450, 600)
        top.maxsize(450, 600)
        # this is where it's set to not be resizable
        top.resizable(0,  0)
        # take a guess what this line does
        top.title("Vital Config to Hex")
        top.configure(background="#d9d9d9")
        top.configure(highlightbackground="#d9d9d9")
        top.configure(highlightcolor="black")
        # this is the actual Label widget that displays the hex equivalent. i increased the font size for ease of use
        self.hex_value = tk.CTkLabel(top,font=("Arial",25))
        # because the window is 450 pixels wide, i made the label 1/3rd the size of the window and set its relative x position to 1/3rd as well. this way it's centered.
        self.hex_value.place(relx=0.333, rely=0.05, height=42, width=150)
        # this is the placeholder text
        self.hex_value.configure(text='''00000000''')
        # this is the function that checks the status of the checkboxes. it's called every time the status of a checkbox changes
        def check_buttons():
            # start out with a list of all of the checkbox variables
            button_list = [check1,check2,check3,check4,check5,check6,check7,check8,check9,check10,check11,check12,check13,check14,check15,check16,check17,check18,check19,check20,check21,check22,check23,check24,check25,check26,check27,check28,check29,check30,check31,check32,]
            # start a blank list for the results
            result = []
            # iterate through each checkbox variable in the list and retrieve its state
            for button in button_list:
                # if it's checked, append a 1 to the results list
                if button.get() == 1:
                    result.append('1')
                # otherwise, append a 0 to the results list
                elif button.get() == 0:
                    result.append('0')
            # turn the results list into a string of 1s and 0s
            result = ''.join(result)
            # create a blank list for grouping them into 4-bit words
            groups = []
            # iterate through the result string
            while len(result) > 0:
                # grab up to index 4 of the result string (non inclusive) and append it to the groups list
                groups.append(result[:4])
                # discard everything before index 4 of the result string
                result = result[4:]
            # this is the function that does the actual calculation. i know i could have done most of this work with built-in libraries and third-party libraries, but what's the fun in that?
            def bin_to_hex(inp):
                total = 0
                # split the string into a list of 4 characters
                inp = list(inp)
                # iterate through the enumerated and reversed copy of the input string
                for ind,i in enumerate(reversed(inp)):
                    # the value to be added will be 2 to the power of the (reversed, keep in mind) index of the bit
                    # for instance:
                    # 0001
                    #    ^ the 1 in this position is equal to 2^0, because it is at the 0th reverse index. this makes it equal to 1.
                    # 0110
                    # this value would equal 6, because we have a 1 in the 1st and 2nd indexes, which means we have (2^1)+(2^2) which equals 6.
                    exp = 2 ** ind
                    # if the current character is a 1, add the value of 2^(reversed index) to the total
                    if i == '1':
                        total += exp
                    # otherwise, simply continue
                    else:
                        continue
                # the final total is the decimal equivalent of this 4-bit binary word
                return total
            # create a blank list to store the decimal equivalents of the 4-bit binary words
            answer = []
            # iterate through each collected group, appending the decimal conversion to the answer list
            for group in groups:
                answer.append(bin_to_hex(group))
            # this is a string of all 16 hexadecimal characters in order, to be used for conversion purposes
            hex = '0123456789ABCDEF'
            # create a blank dictionary to map the hexadecimal characters to their decimal equivalents
            hex_dict = {}
            # iterate through each character in the hex string, assigning it to its decimal equivalent
            for ind,i in enumerate(hex):
                hex_dict[ind] = i
            # create a final list to store the actual answer
            final_answer = []
            # iterate through each answer
            for i in answer:
                # append to the final answer list the hexadecimal equivalent of the decimal equivalent of the 4-bit binary word we converted
                final_answer.append(hex_dict[i])
            # join the final answer list into an 8-bit hexadecimal string
            final_answer = ''.join(final_answer)
            # update the hex_value label to display the final_answer variable
            self.hex_value.configure(text=final_answer)
        # this function returns the position of the top left corner of the window, to use for screenshotting
        def check_pos():
            return (top.winfo_x(),top.winfo_y())
        # this function actually takes the screenshot
        def take_bounded_screenshot():
            # datetime module for filename formatting
            import datetime
            # os,sys modules for currentdir
            import os,sys
            # one of my favorite submodules of tkinter: filedialogs
            from tkinter.filedialog import asksaveasfilename
            # set up the currentdir variable
            currentdir = os.path.dirname(os.path.realpath(__file__))
            parentdir = os.path.dirname(currentdir)
            sys.path.append(parentdir)
            # assign the position of the top left corner of the window to x1 and y1
            x1, y1 = check_pos()
            # assign x2 and y2 to be the (fixed) dimensions of the window
            x2 = 450
            y2 = 600
            # use the pyautogui library to screenshot the exact region needed
            image = pyautogui.screenshot(region=(x1, y1, x2, y2))
            # create a Save As dialog to save the resulting image as a .png file, with currentdir as the initial directory, and the timestamp as the initial filename.
            file_name = asksaveasfilename(initialdir=currentdir,initialfile=f'{datetime.datetime.now().strftime("%f")}.png',defaultextension='.png',filetypes=[("All Files","*.*"),("PNG Images","*.png")])
            # saves the file
            image.save(file_name)
        # setting up the menu bar, importing the actual Menu submodule of tkinter
        from tkinter import Menu
        # create the menu bar and assign it to the toplevel window
        menubar = Menu(top)
        # configure the toplevel window to use the menubar
        top.config(menu=menubar)
        # create a File menu assigned to the menubar, and set to be unable to break away
        file_menu = Menu(menubar,tearoff=False)
        # add commands to the File menu
        file_menu.add_command(label='Snip',command=take_bounded_screenshot)
        file_menu.add_command(label='Exit',command=root.destroy)
        # add the File menu to the Menu menubar. Menu.
        menubar.add_cascade(label="File",menu=file_menu,underline=0)
        # these are the actual checkbox buttons. notice that SPACING. it's perfect.
        # just a reminder that customtkinter is beautiful and easy to use if you already know tkinter.
        self.VS1 = tk.CTkCheckBox(top)
        # placed PERFECTLY where i wanted it to go. and they're all spaced evenly? fantastic.
        self.VS1.place(relx=0.067, rely=0.133, relheight=0.053, relwidth=0.262)
        # this sets the text that goes next to the button, and this text can be clicked instead of clicking directly on the button as well.
        self.VS1.configure(text='''Vital Setting 1''')
        # this assigns the correct variable to the checkbox.
        self.VS1.configure(variable=check1)
        # this assigns a command to the button, which isn't a default option for checkboxes but is there if you need it.
        # in my case, this updates the hex_value label every single time a checkbox is checked, because i'm using the same command for all 32 buttons.
        self.VS1.configure(command=check_buttons)
        # on and on for the next 31 buttons.
        self.VS2 = tk.CTkCheckBox(top)
        self.VS2.place(relx=0.067, rely=0.183, relheight=0.053, relwidth=0.262)
        self.VS2.configure(text='''Vital Setting 2''')
        self.VS2.configure(variable=check2)
        self.VS2.configure(command=check_buttons)
        self.VS3 = tk.CTkCheckBox(top)
        self.VS3.place(relx=0.067, rely=0.233, relheight=0.053, relwidth=0.262)
        self.VS3.configure(text='''Vital Setting 3''')
        self.VS3.configure(variable=check3)
        self.VS3.configure(command=check_buttons)
        self.VS4 = tk.CTkCheckBox(top)
        self.VS4.place(relx=0.067, rely=0.283, relheight=0.053, relwidth=0.262)
        self.VS4.configure(text='''Vital Setting 4''')
        self.VS4.configure(variable=check4)
        self.VS4.configure(command=check_buttons)
        self.VS5 = tk.CTkCheckBox(top)
        self.VS5.place(relx=0.067, rely=0.333, relheight=0.053, relwidth=0.262)
        self.VS5.configure(text='''Vital Setting 5''')
        self.VS5.configure(variable=check5)
        self.VS5.configure(command=check_buttons)
        self.VS6 = tk.CTkCheckBox(top)
        self.VS6.place(relx=0.067, rely=0.383, relheight=0.053, relwidth=0.262)
        self.VS6.configure(text='''Vital Setting 6''')
        self.VS6.configure(variable=check6)
        self.VS6.configure(command=check_buttons)
        self.VS7 = tk.CTkCheckBox(top)
        self.VS7.place(relx=0.067, rely=0.433, relheight=0.053, relwidth=0.262)
        self.VS7.configure(text='''Vital Setting 7''')
        self.VS7.configure(variable=check7)
        self.VS7.configure(command=check_buttons)
        self.VS8 = tk.CTkCheckBox(top)
        self.VS8.place(relx=0.067, rely=0.483, relheight=0.053, relwidth=0.262)
        self.VS8.configure(text='''Vital Setting 8''')
        self.VS8.configure(variable=check8)
        self.VS8.configure(command=check_buttons)
        self.VS9 = tk.CTkCheckBox(top)
        self.VS9.place(relx=0.067, rely=0.533, relheight=0.04, relwidth=0.262)
        self.VS9.configure(text='''Vital Setting 9''')
        self.VS9.configure(variable=check9)
        self.VS9.configure(command=check_buttons)
        self.VS10 = tk.CTkCheckBox(top)
        self.VS10.place(relx=0.067, rely=0.583, relheight=0.04, relwidth=0.278)
        self.VS10.configure(text='''Vital Setting 10''')
        self.VS10.configure(variable=check10)
        self.VS10.configure(command=check_buttons)
        self.VS11 = tk.CTkCheckBox(top)
        self.VS11.place(relx=0.067, rely=0.633, relheight=0.04, relwidth=0.278)
        self.VS11.configure(text='''Vital Setting 11''')
        self.VS11.configure(variable=check11)
        self.VS11.configure(command=check_buttons)
        self.VS12 = tk.CTkCheckBox(top)
        self.VS12.place(relx=0.067, rely=0.683, relheight=0.04, relwidth=0.278)
        self.VS12.configure(text='''Vital Setting 12''')
        self.VS12.configure(variable=check12)
        self.VS12.configure(command=check_buttons)
        self.VS13 = tk.CTkCheckBox(top)
        self.VS13.place(relx=0.067, rely=0.733, relheight=0.04, relwidth=0.278)
        self.VS13.configure(text='''Vital Setting 13''')
        self.VS13.configure(variable=check13)
        self.VS13.configure(command=check_buttons)
        self.VS14 = tk.CTkCheckBox(top)
        self.VS14.place(relx=0.067, rely=0.783, relheight=0.04, relwidth=0.278)
        self.VS14.configure(text='''Vital Setting 14''')
        self.VS14.configure(variable=check14)
        self.VS14.configure(command=check_buttons)
        self.VS15 = tk.CTkCheckBox(top)
        self.VS15.place(relx=0.067, rely=0.833, relheight=0.04, relwidth=0.278)
        self.VS15.configure(text='''Vital Setting 15''')
        self.VS15.configure(variable=check15)
        self.VS15.configure(command=check_buttons)
        self.VS16 = tk.CTkCheckBox(top)
        self.VS16.place(relx=0.067, rely=0.883, relheight=0.04, relwidth=0.284)
        self.VS16.configure(text='''Vital Setting 16''')
        self.VS16.configure(variable=check16)
        self.VS16.configure(command=check_buttons)
        self.VS17 = tk.CTkCheckBox(top)
        self.VS17.place(relx=0.644, rely=0.133, relheight=0.053, relwidth=0.284)
        self.VS17.configure(text='''Vital Setting 17''')
        self.VS17.configure(variable=check17)
        self.VS17.configure(command=check_buttons)
        self.VS18 = tk.CTkCheckBox(top)
        self.VS18.place(relx=0.644, rely=0.183, relheight=0.053, relwidth=0.282)
        self.VS18.configure(text='''Vital Setting 18''')
        self.VS18.configure(variable=check18)
        self.VS18.configure(command=check_buttons)
        self.VS19 = tk.CTkCheckBox(top)
        self.VS19.place(relx=0.644, rely=0.233, relheight=0.053, relwidth=0.282)
        self.VS19.configure(text='''Vital Setting 19''')
        self.VS19.configure(variable=check19)
        self.VS19.configure(command=check_buttons)
        self.VS20 = tk.CTkCheckBox(top)
        self.VS20.place(relx=0.644, rely=0.283, relheight=0.053, relwidth=0.282)
        self.VS20.configure(text='''Vital Setting 20''')
        self.VS20.configure(variable=check20)
        self.VS20.configure(command=check_buttons)
        self.VS21 = tk.CTkCheckBox(top)
        self.VS21.place(relx=0.644, rely=0.333, relheight=0.04, relwidth=0.282)
        self.VS21.configure(text='''Vital Setting 21''')
        self.VS21.configure(variable=check21)
        self.VS21.configure(command=check_buttons)
        self.VS22 = tk.CTkCheckBox(top)
        self.VS22.place(relx=0.644, rely=0.383, relheight=0.04, relwidth=0.282)
        self.VS22.configure(text='''Vital Setting 22''')
        self.VS22.configure(variable=check22)
        self.VS22.configure(command=check_buttons)
        self.VS23 = tk.CTkCheckBox(top)
        self.VS23.place(relx=0.644, rely=0.433, relheight=0.04, relwidth=0.282)
        self.VS23.configure(text='''Vital Setting 23''')
        self.VS23.configure(variable=check23)
        self.VS23.configure(command=check_buttons)
        self.VS24 = tk.CTkCheckBox(top)
        self.VS24.place(relx=0.644, rely=0.483, relheight=0.04, relwidth=0.282)
        self.VS24.configure(text='''Vital Setting 24''')
        self.VS24.configure(variable=check24)
        self.VS24.configure(command=check_buttons)
        self.VS25 = tk.CTkCheckBox(top)
        self.VS25.place(relx=0.644, rely=0.533, relheight=0.04, relwidth=0.282)
        self.VS25.configure(text='''Vital Setting 25''')
        self.VS25.configure(variable=check25)
        self.VS25.configure(command=check_buttons)
        self.VS26 = tk.CTkCheckBox(top)
        self.VS26.place(relx=0.644, rely=0.583, relheight=0.04, relwidth=0.282)
        self.VS26.configure(text='''Vital Setting 26''')
        self.VS26.configure(variable=check26)
        self.VS26.configure(command=check_buttons)
        self.VS27 = tk.CTkCheckBox(top)
        self.VS27.place(relx=0.644, rely=0.633, relheight=0.04, relwidth=0.282)
        self.VS27.configure(text='''Vital Setting 27''')
        self.VS27.configure(variable=check27)
        self.VS27.configure(command=check_buttons)
        self.VS28 = tk.CTkCheckBox(top)
        self.VS28.place(relx=0.644, rely=0.683, relheight=0.04, relwidth=0.282)
        self.VS28.configure(text='''Vital Setting 28''')
        self.VS28.configure(variable=check28)
        self.VS28.configure(command=check_buttons)
        self.VS29 = tk.CTkCheckBox(top)
        self.VS29.place(relx=0.644, rely=0.733, relheight=0.04, relwidth=0.282)
        self.VS29.configure(text='''Vital Setting 29''')
        self.VS29.configure(variable=check29)
        self.VS29.configure(command=check_buttons)
        self.VS30 = tk.CTkCheckBox(top)
        self.VS30.place(relx=0.644, rely=0.783, relheight=0.04, relwidth=0.282)
        self.VS30.configure(text='''Vital Setting 30''')
        self.VS30.configure(variable=check30)
        self.VS30.configure(command=check_buttons)
        self.VS31 = tk.CTkCheckBox(top)
        self.VS31.place(relx=0.644, rely=0.833, relheight=0.04, relwidth=0.282)
        self.VS31.configure(text='''Vital Setting 31''')
        self.VS31.configure(variable=check31)
        self.VS31.configure(command=check_buttons)
        self.VS32 = tk.CTkCheckBox(top)
        self.VS32.place(relx=0.644, rely=0.883, relheight=0.04, relwidth=0.282)
        self.VS32.configure(text='''Vital Setting 32''')
        self.VS32.configure(variable=check32)
        self.VS32.configure(command=check_buttons)
        # finally done!
if __name__ == '__main__':
    vp_start_gui()